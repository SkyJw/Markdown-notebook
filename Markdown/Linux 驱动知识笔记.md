# Linux 驱动知识笔记

### 原子操作

​		原子操作说白了类似定义一个变量作为标志，通过增减标志，来对临界资源进行访问。狭义的、在单CPU情况下理解原子操作，即不可再分的操作，具有排他性的操作，执行原子操作的过程中不可被打断，直至原子操作完成。到现在的SMP中，因为存在多个同时执行的cpu，所以不可能一个cpu进行原子操作时，其他CPU都不执行任意操作。<font color=red>所以此处的原子操作引申为原子变量在原子操作中，只能被一个CPU操作，不能被其他CPU访问。</font>

​		举例来说明，假如现在有一个临界资源，使用int can_use = 1，作为标志位控制使用。假设出现如下情况：

1. CPU0 获取can_use（值为1）到其寄存器

2. CPU1 获取can_use（值为1）到其寄存器

3. CPU0 判断可以使用临界资源，并将can_use清零

4. CPU1 判断可以使用临界资源，并将can_use清零

5. CPU0 将寄存器中的can_use（值为0）写回内存

6. CPU1 将寄存器中的can_use（值为1）写回内存

   这个情况下，CPU0、CPU1并没有能够真的实现互斥访问临界资源，导致出错。<font color=red>而使用原子操作时，在第一步CPU0已经获取can_use后，第二步中的CPU1无法访问can_use，从而避免了这种情况的发生。</font>

### 内存和I/O访问

#### 内存空间和I/O空间

​	I/O空间是X86处理器中的概念，独立与内存空间，单独对外设寄存器进行编址。需要使用特定的I/O命令in、out来访问。

​	在大多数嵌入式处理器中（如arm、powerpc等）并没有I/O空间概念，仅存在内存空间，外设寄存器与存储器统一编址。

​	即使是X86处理器，如果是自己设计电路板，外设仍然只可以挂接在内存空间。此时CPU可以像访问内存一样去访问外设端口。所以内存空间是必须的，外设空间是可选的。

#### 内存管理单元MMU

主要功能：

- 虚拟地址和物理地址的映射
- 内存访问权限的保护
- cache缓存控制等

重要概念：

- 分页

  将内存按一定大小，如4K，分成一页一页

- 页表

  如4G内存，按4K分页，则产生2的20次方个页框（一个页框就是4K的内存区域），这2的20次方个页框的地址需要4MB内存进行存放，这就是页表

- 虚拟地址

  虚拟地址就是由页表地址+页内偏移所组成

- 页表基地址寄存器

  存放页表基地址

- TLB快表

  根据局部性原理，使用高速cache缓存一部分常用页表项，用于快速进行虚拟地址到物理地址的转换

- 多级页表

  就是对上例中的4MB页表项之上再做一层页表，比如把4MB页表空间再按4K进行分割，则会得到2的8次方个二级页表地址。多级

#### 内存存取

##### 内核空间内存动态申请

- kmalloc(size_t size, int flags)

  常用的标志为GFP_KERNEL，含义是在内核空间进程中分配内存，使用该标志分配内存时，若暂时不能满足，则会睡眠等待，所以不能在中断、自旋锁、内核定时器等情况使用。此时应该使用GFP_ATOMIC标志，此时，若不满足会直接返回。

- __get_free_pages()

  该方法本质是Linux内核最底层获取空闲内存的方法。底层buddy算法是2^n页为单位管理空闲内存，所以该方法也是以2^n页为单位。（一页为4K）最多分配1024或2048页，即4M或8M，具体取决于硬件平台。

- vmalloc()

  一般只为存在软件中的较大的顺序缓冲区分配内存。一般不用来分配小内存，其开销远大于__get_free_pages()。分配的内存在物理上不连续，不可作为DMA缓存。

- slab与内存池

  slab相当于对分配的页内存进行二次管理。

##### 设备I/O端口和I/O内存的访问

​	<font color=red>当外部设备的寄存器位于I/O空间中时，访问这些寄存器的方法被称为I/O端口，当外部设备的寄存器位于内存空间时，访问这些寄存器的方法被称为I/O内存</font>

###### I/O内存

​	想要访问位于内存空间的外设寄存器时，因为Linux无法直接访问物理地址，所以需要将外设中的I/O内存地址映射为虚拟地址，完成这个操作的函数就是ioremap()

​	映射完成后，Linux推荐使用一组标准的API来完成设备内存的访问，如readb/readw/read/l、writeb/writew/writel等

### dump_stack()

打印栈回朔，用于调试

### 中断底半部

#### tasklet

## 岗位要求中看到的一些技术及要求

### rootfs的制作

### 多进程、多线程



