# Linux内核设计与实现笔记

## 第二章 从内核出发

### 内联函数(inline)

​	定义时，前面应该使用static，如下：

​	` static inline void xxx(unsigned int  x) `

​	常用于定义使用频繁，且代码量较小的函数。实践中，一般将内联函数定义到头文件中，<font color=red>因为使用了static限定，所以编译时，不会创建函数体。</font>如果一个内联函数仅在一个源文件中使用，那么也可以将该内联函数定义在源文件的开头处。

### 内核中不要进行浮点运算

​	内核中不应该去进行浮点运算

### 内核中容积小而固定的栈

​	用户空间可以从栈上分配大量空间来存放变量，甚至巨大的结构体或是很大的数组，因为用户空间栈大，且可以动态增长。而内核空间栈很小，与体系结构有关，一般来说32位为8K，64位为16K。

​	思考：<font color=red>按照这个说法，可以推测出两点</font>

- 在程序中声明定义变量时，是从栈空间中申请的
- 内核中定义各种结构体，都是通过定义指针，然后分配内存的方式，就是避免栈超出

## 第四章 进程调度

### 多任务

#### 抢占式多任务

​	由调度程序来决定什么时候停止一个进程的运行，以便其他进程能够得到执行机会，这个强制的挂起动作就叫抢占。进程在被抢占之前运行的时间是预先设置好的，即进程的时间片。

#### 非抢占多任务

​	在非抢占多任务模式下，除非进程自己主动停止运行，否则它会一直执行。进程主动挂起自己的操作称为让步

### Linux的进程调度

#### O(1)调度程序缺点

​	对与调度响应时间敏感的程序有先天不足，这些程序称为交互程序，如用户交互程序

### Linux调度策略

#### I/O消耗型进程

​	指进程大部分时间用来提交I/O请求或者是等待I/O请求

#### 处理器消耗型进程

​	指进程大部分时间耗费在执行代码上，除非被抢占，否则他们通常一直都不停的运行。

#### 进程优先级

- nice值
  - 范围-20到+19，默认为0，值越大优先级越低
  - unix系统的标准化概念
- 实时优先级
  - 值可以配置
  - 范围从0到99，值越大优先级越高
  - 任何实时进程优先级都高于普通进程。思考：<font color=red>实时进程和普通进程是linux中不同的两种进程类型</font>

#### 时间片

​	即进程在被抢占前所能持续运行的时间，即分配给各个进程的一次运行机会的时间长度。

​	时间片过长会导致系统对交互响应表现欠佳，时间片太短会明显增大进程切换带来的处理器耗时。

​	I/O消耗型进程不需要时间片长，因为它需要处理器运行的部分少，更多的是I/O操作，处理器消耗型进程则希望时间片越长越好，这样可以使它们的cache命中率更高。

​	<font color=red>Linux的CFS（完全公平调度器）并没有直接分配时间片到进程，而是将处理器的使用比划分给进程。这样进程所获得的处理器时间，将和系统负载密切相关。（不太明白此处如何和系统负载挂钩）</font>

​	此外分配给进程的处理器使用比也和nice值有关，nice值越低，权重越高，抢占更多的处理器使用比。

​	<font color=blue>Linux CFS调度器的抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，则新进程立刻投入运行，抢占当前进程。否则，将推迟其运行。</font>（这句又不太懂，到底是“新的可运行程序消耗了多少处理器使用比”还是“新的可运行程序拥有多少处理器使用比”）

​	<font color=red>思考：首先这样理解处理器使用比，单位时间内，某个进程占据cpu的时间。举例说明，1秒时间内，某个进程可以占据cpu 0.5秒，则该进程使用比则为50%。这点明确后，再来看上面蓝字，“新的可运行程序”的意思应该是相较与当前运行的程序而言，而非是指的刚刚进入运行队列的程序，也就是说“新的可运行程序”应该是在运行队列中，但还没有运行的程序。这点很重要，可以解答上面括号疑问。所以这样看来，蓝字中的“抢占时机取决于新的可运行程序消耗了多少处理器使用比”这句话就明朗了，举例说明，当前运行进程分配了10%使用比，消耗了5%使用比，队列中的下个进程分配了20%使用比，而消耗了4%使用比，则此时就会发送调度。所以说CFS调度器的调度时机，不取决与分配了多少使用比，而在于消耗了多少使用比。这样也符合让所有进程都能得到运行的基本要求</font>

### Linux调度的实现

#### 4.5.1 时间记账

​	简单来说，时间记账就是记录系统中进程的运行时间。

#### 4.5.2 进程选择

​	CFS选择进程，就是选择vuntime最小的进程。如何找出vruntime最小的进程呢？首先进程队列通过红黑树进行存储，红黑树是一种以树节点形式存储的数据，这些数据都会对应一个键值，可以通过键值来快速检索节点上的数据。（时间复杂度是O(log(n))?)

##### 1. 挑选下一个任务

​	假设已经有一个存储了系统所有可运行进程的红黑树，其中节点的键值便是可运行的进程的虚拟运行时间vruntime。CFS调度就会选择该树中最左侧的叶子节点。<font color=red>这句话也就是说，红黑树最左侧叶子节点键值最小。</font>所以从红黑树的根节点出发沿着左边子节点向下查找，一直到叶子节点即可获得vruntime最小的那个进程。

​	实际使用中，其实是把最左叶子节点缓存在rb_leftmost中。

##### 2. 向树中加入进程

​	向进程的红黑树加入进程，以及缓存最左叶子节点发生在进程变为可运行状态（被唤醒）时，或者是通过fork()调用第一次创建进程时。

##### 3. 从树中删除进程

​	删除进程的动作发生在进程堵塞(变为不可运行态)或者终止时(结束运行)

#### 4.5.3 调度器入口

​	进程调度的主要入口点是函数schedule()。该函数会找到一个最高优先级的调度器类，再从该类中获取到下一个应该运行的进程。schedule()中主要还是调用pick_next_task()函数进行相关操作。

​	<font color=red>每一个调度类都实现了pick_next_task()函数，它会返回指向下一个可运行进程的指针。</font>

#### 4.5.4 睡眠和唤醒

​	休眠（被阻塞）的进程处于一个特殊的不可执行状态。若没有这种状态，休眠就必须以轮询方式实现（思考：如果不像这样使用两个队列存储休眠和运行进程，那就要用标志位来标识休眠进程，所以叫轮询实现）。

##### 1. 等待队列

​	<font color=red>等待队列的新理解：等待队列不是一种内核驱动中实现阻塞的方法，它其实更厉害，所有内核中的休眠都要依赖与等待队列，它是内核的一种基本机制，因为休眠则必须有唤醒，而等待队列正是将休眠进程和唤醒进程联系起来的机制。</font>

##### 2. 唤醒

​	唤醒通过wake_up()进行，它会唤醒指定等待队列上的所有进程。

### 4.6 抢占和上下文切换

​	上下文切换，即从一个可执行进程，切换到另一个可执行进程。由context_switch()函数负责处理。每当一个新的进程被选出来准备投入运行的时候，schedule()就会调用该函数。

​	主要完成如下两个工作：

- 调用switch_mm()，将虚拟内存从上一个进程映射到新进程
- 调用switch_to()，从上一个进程的处理器状态切换到新进程处理器状态，包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结构相关的状态信息，都以进程为单位进行保存。

#### 4.6.1 用户抢占

#### 4.6.2 内核抢占

### 4.7 实时调度策略

​	Linux提供了两种实时调度策略：

- SCHED_FIFO

  一种简单的、先入先出的调度算法，不使用时间片。一个SCHED_FIFO级别的进程处于运行状态时，就会一直执行，直至它受到阻塞或者显示的释放处理器。只有更高优先级的SCHED_FIFO或者SCHED_RR任务才可以抢占SCHED_FIFO任务。

- SCHED_RR

  SCHED_RR相较于SCHED_FIFO而言，增加了时间片机制，是一种实时轮流调度算法

​	这两种实时算法实现，都是静态优先级，即内核不会实时计算优先级。Linux的实时调度是软实时，即内核会尽力去进行实时调度，但不能保证总能实时。硬实时，就是指在一定条件下，一定可以实时完成调度。

### 4.8 与调度相关的系统调用

### 4.9 小结

## 第五章 系统调用

​	系统调用是内核提供给用户进程，让其与内核进行交互的一组接口。这些接口让应用程序受限的访问硬件设备，提供了创建新进程并与已有进程进行通信的机制，也提供了申请操作系统其他资源的能力。

### 5.1 与内核通信

​		系统调用是用户进程和硬件设备之间的一个中间层。作用有三：

- 为用户空间提供硬件抽象接口
- 保证系统稳定和安全
- 使进程独立，实现每个进程都在一个虚拟系统中

### 5.2 API、POSIX和C库

​	用户空间一般不直接调用系统调用，而是调用应用编程接口（API），再由API调用系统调用。Linux最流行的API即POSIX标准。系统调用一般作为C库的一部分提供。

### 5.3 系统调用

#### 5.3.1 系统调用号

​	用于标识系统调用，用户空间传进内核空间的是系统调用号。

#### 5.3.2 系统调用性能

​	比其他系统较快，原因有二：

- linux上下文切换快
- 系统调用以及系统调用处理快

### 5.4 系统调用处理程序

​	系统调用是通过软中断实现，需要系统调用时，用户空间触发128号异常（x86），使得操作系统陷入内核态，128号异常的异常处理程序即是系统调用处理程序，名叫system_call()。

#### 5.4.1 指定恰当的系统调用

​	所有系统调用陷入内核的方式都一样，通过128号异常。如何区别各个系统调用呢？就是之前提到的系统中断号。用户空间在陷入内核前，将系统中断号存入eax寄存器，然后内核再从该寄存器取出即可。

### 5.5 系统调用的实现

#### 5.5.1 实现系统调用

#### 5.5.2 参数验证

​	内核接收一个用户空间的指针之前，内核必须保证：

- 指针指向的内存属于用户空间
- 指针指向的内存区域在该进程的地址空间
- 读、写、可执行的内存应进行对应标记

​    内核空间和用户空间之间的数据拷贝，copy_to_user(),copy_from_user()。这两个函数均有可能引起阻塞，发生在用户数据页被换出到硬盘上而不是在物理内存上的时候。

### 5.6 系统调用上下文

​	内核执行系统调用时处于进程上下文，可休眠，可抢占。

#### 5.6.1 绑定一个系统调用的最后步骤

#### 5.6.2 从用户空间访问系统调用

#### 5.6.3 为什么不通过系统调用的方式实现

#### 5.7 小结

## 第六章 内核数据结构

### 6.1 链表

​	链表是一种存放和操作可变数量元素的数据结构。链表和数组的不同之处在于，它所包含的元素都是动态创建并插入链表的，编译时不必知道具体需要创建多少个元素，而且也不需要占用连续的内存。各个元素之间通过地址指针组织到一起。

#### 6.1.1 单向链表和双向链表

#### 6.1.2 环形链表

​	Linux内核标准链表是环形双向链表。

#### 6.1.3 沿链表移动

​	沿链表移动访问，只能一个一个元素的线性访问，不能随机访问。

​	首元素有时候会用特殊的指针表示，称为头指针，该元素不用来存储数据，只用来快速定位链表头尾元素。

#### 6.1.4 Linux内核中链表的实现

##### 1. 链表数据结构

```c
	struct list_head {
		struct list_head *next;
		struct list_head *prev;
	}
```

​	linux中链表不像常规的链表那样，将数据结构体放入链表，而是先定义好链表结构，再把链表结构放入需要组织成链表的数据结构中。list_head本身并没有意义，它需要被嵌入到你自己的数据结构中才能生效。

​	<font color=red>如何通过list_head找到本节点的数据呢，这就需要container_of宏，这个宏的作用是，给定一个数据结构成员指针、该数据结构的定义和该数据结构成员名字，从而获取到指向这个数据结构的指针。该宏的原理是，一个给定结构中的变量偏移在编译时已经确定了，已知结构中的一个成员的地址，可以反推出结构的地址。</font>

​	在Linux内核中，使用list_entry()方法，封装了一下container_of()。

##### 2. 定义一个链表

​	首先，在自己的结构体中，增加一个struct list_head list成员。

```c
	struct fox {
			unsigned long tail_length;
			unsigned long weight;
			struct list_head list;
	}
```

​	链表在使用前需要初始化，因为链表的应用情景中，多数元素都是动态创建的，所以使用链表时，最常用的方法是在运行时进行初始化链表。

```c
	struct fox *red_fox;
	red_fox = kmalloc(sizeof(*red_fox), GFP_KERNEL);
	red_fox->tail_length = 40;
	red_fox->weight = 6;
	INIT_LIST_HEAD(&red_fox->list);
```

​	INIT_LIST_HEAD(ptr)宏的作用是初始化一个链表，即使一个链表的头尾指针都指向自己，具体实现如下：

```c
#define INIT_LIST_HEAD(ptr) do { \
    (ptr)->next = (ptr); (ptr)->prev = (ptr); \
} while (0)
```

​	这种方式是事先在自己的数据结构体中定义好链表list_head，然后在程序运行过程中动态的分配自己的数据结构体时，采用这个方式来动态的初始化list_head链表。

​	假如自己的数据结构体是编译期间直接定义的（全局变量方式，而不是实时分配内存），这个时候应该采用` LIST_HEAD_INIT(name) `宏，该宏实现如下：

```c
#define LIST_HEAD_INIT(name) { &(name), &(name) }
```

​	可以看出，两个宏作用均是初始化链表，使之头尾指针指向自己。区别在于一个在动态执行时使用，一个在定义时使用。<font color=red>思考：可以类比变量赋初值和赋值。</font>

##### 3. 链表头

​	按照如上的方式，已经有了一个可供使用的链表结构。不过一般还提供一个特殊的指针来索引整个链表，也就是链表头，内核提供的大多数链表相关函数都要接收这个链表头参数。构造一个链表头的方式为：static LIST_HEAD(head_name);具体实现如下：

```c
#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)
```

​	可以看出，LIST_HEAD(name)宏，其实就是定义了一个头尾指针指向自己的list_head结构体。这样可以快速定位头尾，便于插入等操作。

#### 6.1.5 操作链表

​	内核提供了一组以一个或多个list_head结构体指针做参数、复杂度为O(1)的函数来操作链表。

##### 1. 向链表中增加一个节点

```c
list_add(struct list_head *new, struct list_head *head)
```

​	该函数向指定链表的head节点后面插入new节点。<font color=red>因为链表是循环的，而且通常没有首尾节点的概念，所以你可以把任何一个节点当成head。</font>

##### 2. 从链表中删除一个节点

```c
list_del(struct list_head *entry)
```

