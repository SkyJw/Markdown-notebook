# Linux内核设计与实现笔记

## 第二章 从内核出发

### 内联函数(inline)

​	定义时，前面应该使用static，如下：

​	` static inline void xxx(unsigned int  x) `

​	常用于定义使用频繁，且代码量较小的函数。实践中，一般将内联函数定义到头文件中，<font color=red>因为使用了static限定，所以编译时，不会创建函数体。</font>如果一个内联函数仅在一个源文件中使用，那么也可以将该内联函数定义在源文件的开头处。

### 内核中不要进行浮点运算

​	内核中不应该去进行浮点运算

### 内核中容积小而固定的栈

​	用户空间可以从栈上分配大量空间来存放变量，甚至巨大的结构体或是很大的数组，因为用户空间栈大，且可以动态增长。而内核空间栈很小，与体系结构有关，一般来说32位为8K，64位为16K。

​	思考：<font color=red>按照这个说法，可以推测出两点</font>

- 在程序中声明定义变量时，是从栈空间中申请的
- 内核中定义各种结构体，都是通过定义指针，然后分配内存的方式，就是避免栈超出

## 第四章 进程调度

### 多任务

#### 抢占式多任务

​	由调度程序来决定什么时候停止一个进程的运行，以便其他进程能够得到执行机会，这个强制的挂起动作就叫抢占。进程在被抢占之前运行的时间是预先设置好的，即进程的时间片。

#### 非抢占多任务

​	在非抢占多任务模式下，除非进程自己主动停止运行，否则它会一直执行。进程主动挂起自己的操作称为让步

### Linux的进程调度

#### O(1)调度程序缺点

​	对与调度响应时间敏感的程序有先天不足，这些程序称为交互程序，如用户交互程序

### Linux调度策略

#### I/O消耗型进程

​	指进程大部分时间用来提交I/O请求或者是等待I/O请求

#### 处理器消耗型进程

​	指进程大部分时间耗费在执行代码上，除非被抢占，否则他们通常一直都不停的运行。

#### 进程优先级

- nice值
  - 范围-20到+19，默认为0，值越大优先级越低
  - unix系统的标准化概念
- 实时优先级
  - 值可以配置
  - 范围从0到99，值越大优先级越高
  - 任何实时进程优先级都高于普通进程。思考：<font color=red>实时进程和普通进程是linux中不同的两种进程类型</font>

#### 时间片

​	即进程在被抢占前所能持续运行的时间，即分配给各个进程的一次运行机会的时间长度。

​	时间片过长会导致系统对交互响应表现欠佳，时间片太短会明显增大进程切换带来的处理器耗时。

​	I/O消耗型进程不需要时间片长，因为它需要处理器运行的部分少，更多的是I/O操作，处理器消耗型进程则希望时间片越长越好，这样可以使它们的cache命中率更高。

​	<font color=red>Linux的CFS（完全公平调度器）并没有直接分配时间片到进程，而是将处理器的使用比划分给进程。这样进程所获得的处理器时间，将和系统负载密切相关。（不太明白此处如何和系统负载挂钩）</font>

​	此外分配给进程的处理器使用比也和nice值有关，nice值越低，权重越高，抢占更多的处理器使用比。

​	<font color=blue>Linux CFS调度器的抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，则新进程立刻投入运行，抢占当前进程。否则，将推迟其运行。</font>（这句又不太懂，到底是“新的可运行程序消耗了多少处理器使用比”还是“新的可运行程序拥有多少处理器使用比”）

​	<font color=red>思考：首先这样理解处理器使用比，单位时间内，某个进程占据cpu的时间。举例说明，1秒时间内，某个进程可以占据cpu 0.5秒，则该进程使用比则为50%。这点明确后，再来看上面蓝字，“新的可运行程序”的意思应该是相较与当前运行的程序而言，而非是指的刚刚进入运行队列的程序，也就是说“新的可运行程序”应该是在运行队列中，但还没有运行的程序。这点很重要，可以解答上面括号疑问。所以这样看来，蓝字中的“抢占时机取决于新的可运行程序消耗了多少处理器使用比”这句话就明朗了，举例说明，当前运行进程分配了10%使用比，消耗了5%使用比，队列中的下个进程分配了20%使用比，而消耗了4%使用比，则此时就会发送调度。所以说CFS调度器的调度时机，不取决与分配了多少使用比，而在于消耗了多少使用比。这样也符合让所有进程都能得到运行的基本要求</font>

### Linux调度的实现

#### 4.5.1 时间记账

​	简单来说，时间记账就是记录系统中进程的运行时间。

#### 4.5.2 进程选择

​	CFS选择进程，就是选择vuntime最小的进程。如何找出vruntime最小的进程呢？首先进程队列通过红黑树进行存储，红黑树是一种以树节点形式存储的数据，这些数据都会对应一个键值，可以通过键值来快速检索节点上的数据。（时间复杂度是O(log(n))?)

##### 1. 挑选下一个任务

​	假设已经有一个存储了系统所有可运行进程的红黑树，其中节点的键值便是可运行的进程的虚拟运行时间vruntime。CFS调度就会选择该树中最左侧的叶子节点。<font color=red>这句话也就是说，红黑树最左侧叶子节点键值最小。</font>所以从红黑树的根节点出发沿着左边子节点向下查找，一直到叶子节点即可获得vruntime最小的那个进程。

​	实际使用中，其实是把最左叶子节点缓存在rb_leftmost中。

##### 2. 向树中加入进程

​	向进程的红黑树加入进程，以及缓存最左叶子节点发生在进程变为可运行状态（被唤醒）时，或者是通过fork()调用第一次创建进程时。

##### 3. 从树中删除进程

​	删除进程的动作发生在进程堵塞(变为不可运行态)或者终止时(结束运行)

#### 4.5.3 调度器入口

​	进程调度的主要入口点是函数schedule()。该函数会找到一个最高优先级的调度器类，再从该类中获取到下一个应该运行的进程。schedule()中主要还是调用pick_next_task()函数进行相关操作。

​	<font color=red>每一个调度类都实现了pick_next_task()函数，它会返回指向下一个可运行进程的指针。</font>

#### 4.5.4 睡眠和唤醒

​	休眠（被阻塞）的进程处于一个特殊的不可执行状态。若没有这种状态，休眠就必须以轮询方式实现（思考：如果不像这样使用两个队列存储休眠和运行进程，那就要用标志位来标识休眠进程，所以叫轮询实现）。

##### 1. 等待队列

​	<font color=red>等待队列的新理解：等待队列不是一种内核驱动中实现阻塞的方法，它其实更厉害，所有内核中的休眠都要依赖与等待队列，它是内核的一种基本机制，因为休眠则必须有唤醒，而等待队列正是将休眠进程和唤醒进程联系起来的机制。</font>

##### 2. 唤醒

​	唤醒通过wake_up()进行，它会唤醒指定等待队列上的所有进程。

### 4.6 抢占和上下文切换

​	上下文切换，即从一个可执行进程，切换到另一个可执行进程。由context_switch()函数负责处理。每当一个新的进程被选出来准备投入运行的时候，schedule()就会调用该函数。

​	主要完成如下两个工作：

- 调用switch_mm()，将虚拟内存从上一个进程映射到新进程
- 调用switch_to()，从上一个进程的处理器状态切换到新进程处理器状态，包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结构相关的状态信息，都以进程为单位进行保存。

#### 4.6.1 用户抢占

​	

