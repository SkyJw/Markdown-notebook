# Linux内核设计与实现笔记

## 第二章 从内核出发

### 内联函数(inline)

​	定义时，前面应该使用static，如下：

​	` static inline void xxx(unsigned int  x) `

​	常用于定义使用频繁，且代码量较小的函数。实践中，一般将内联函数定义到头文件中，<font color=red>因为使用了static限定，所以编译时，不会创建函数体。</font>如果一个内联函数仅在一个源文件中使用，那么也可以将该内联函数定义在源文件的开头处。

### 内核中不要进行浮点运算

​	内核中不应该去进行浮点运算

### 内核中容积小而固定的栈

​	用户空间可以从栈上分配大量空间来存放变量，甚至巨大的结构体或是很大的数组，因为用户空间栈大，且可以动态增长。而内核空间栈很小，与体系结构有关，一般来说32位为8K，64位为16K。

​	思考：<font color=red>按照这个说法，可以推测出两点</font>

- 在程序中声明定义变量时，是从栈空间中申请的
- 内核中定义各种结构体，都是通过定义指针，然后分配内存的方式，就是避免栈超出

## 第四章 进程调度

### 多任务

#### 抢占式多任务

​	由调度程序来决定什么时候停止一个进程的运行，以便其他进程能够得到执行机会，这个强制的挂起动作就叫抢占。进程在被抢占之前运行的时间是预先设置好的，即进程的时间片。

#### 非抢占多任务

​	在非抢占多任务模式下，除非进程自己主动停止运行，否则它会一直执行。进程主动挂起自己的操作称为让步

### Linux的进程调度

#### O(1)调度程序缺点

​	对与调度响应时间敏感的程序有先天不足，这些程序称为交互程序，如用户交互程序

### Linux调度策略

#### I/O消耗型进程

​	指进程大部分时间用来提交I/O请求或者是等待I/O请求

#### 处理器消耗型进程

​	指进程大部分时间耗费在执行代码上，除非被抢占，否则他们通常一直都不停的运行。

#### 进程优先级

- nice值
  - 范围-20到+19，默认为0，值越大优先级越低
  - unix系统的标准化概念
- 实时优先级
  - 值可以配置
  - 范围从0到99，值越大优先级越高
  - 任何实时进程优先级都高于普通进程。思考：<font color=red>实时进程和普通进程是linux中不同的两种进程类型</font>

#### 时间片

​	即进程在被抢占前所能持续运行的时间，即分配给各个进程的一次运行机会的时间长度。

​	时间片过长会导致系统对交互响应表现欠佳，时间片太短会明显增大进程切换带来的处理器耗时。

​	I/O消耗型进程不需要时间片长，因为它需要处理器运行的部分少，更多的是I/O操作，处理器消耗型进程则希望时间片越长越好，这样可以使它们的cache命中率更高。

​	<font color=red>Linux的CFS（完全公平调度器）并没有直接分配时间片到进程，而是将处理器的使用比划分给进程。这样进程所获得的处理器时间，将和系统负载密切相关。（不太明白此处如何和系统负载挂钩）</font>

​	此外分配给进程的处理器使用比也和nice值有关，nice值越低，权重越高，抢占更多的处理器使用比。

​	<font color=blue>Linux CFS调度器的抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，则新进程立刻投入运行，抢占当前进程。否则，将推迟其运行。</font>（这句又不太懂，到底是“新的可运行程序消耗了多少处理器使用比”还是“新的可运行程序拥有多少处理器使用比”）

​	<font color=red>思考：首先这样理解处理器使用比，单位时间内，某个进程占据cpu的时间。举例说明，1秒时间内，某个进程可以占据cpu 0.5秒，则该进程使用比则为50%。这点明确后，再来看上面蓝字，“新的可运行程序”的意思应该是相较与当前运行的程序而言，而非是指的刚刚进入运行队列的程序，也就是说“新的可运行程序”应该是在运行队列中，但还没有运行的程序。这点很重要，可以解答上面括号疑问。所以这样看来，蓝字中的“抢占时机取决于新的可运行程序消耗了多少处理器使用比”这句话就明朗了，举例说明，当前运行进程分配了10%使用比，消耗了5%使用比，队列中的下个进程分配了20%使用比，而消耗了4%使用比，则此时就会发送调度。所以说CFS调度器的调度时机，不取决与分配了多少使用比，而在于消耗了多少使用比。这样也符合让所有进程都能得到运行的基本要求</font>



​	



