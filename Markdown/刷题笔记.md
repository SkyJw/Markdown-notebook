# 刷题笔记

## 一. 字符串相关

### 1.1 C++中处理字符串的方法

​	做字符串翻转题目时候，用C很吃亏，看了别人解答。发现C++中直接用string类型来做这类题目比较简单，目前看到了：

- str.size()

  可以直接获取字符串长度，很方便进行遍历或者是翻转

- reverse()方法，头文件在<algorithm>

  可以直接翻转字符串，参数是字符串起点和终点，如` reverse(s.begin(), s.end()) `

### 1.2 python中的字符串处理方法

- str.join()方法

  join()方法用于将序列中的元素以指定的字符连接生成一个新的字符串


## 二. 动态规划相关

### 2.1 以leetcode No.5 最长回文子串说明

#### 2.1.1 解体思路

​	往往这种题有个特征，可以把问题细化成一个一个层叠嵌套的小问题。例如，判断是否回文字符串，可以判断去掉头尾字符的子串是不是回文串。

​	所以关键是要找出这个规律，把大问题化成嵌套的小问题，这个过程也就是找到最优子结构。找到最优子结构后，就要构建一个状态数组，也就是DP数组。可能是一维的，也可能是二维的（据说二维都能转化为一维，比较难想，先不管），数组长度一般和问题规模一致。这个数组是什么意思呢，一般来说就是大问题化成小问题时候，小问题的状态。也就是说数组下标越小，也就是问题分解的越小的情况的时候的解。也就是说数组最后一个值，往往就是我们所求问题的解。但是No.5这题例外。实际还是要具体问题具体分析。这个数组的第一个元素，往往称之为边界，通过第一个元素往后推，确定整个数组的状态即可解题。

​	怎么确定数组的状态呢，这个就需要状态转移方程，当前的状态由之前的状态怎么怎么处理后可以得到，也就是说数组的后一个值，和前一个值直接的联系。（和高中的递推方程差不多的意思，或者说，有时候就是高中的递推）。总结基本步骤如下：

- 找出最优子结构
- 定义状态数组
- 找出状态转移方程
- 确定状态数组中每一个元素的状态
- 从确定后的状态数组获取结果

#### 2.1.2 这一题中需要注意的地方

- 列表生成式中if的用法

```python
[i for i in range(10) if i < 6]
[i if i < 20 else i -- for i in rang(100)]
```

- 不要忘记特殊的用例，如空输入，单输入等
- 二维状态数组时，遍历二维数组的顺序尤为重要，不要先遍历到了后面的元素，但是这个元素所依赖的前面的元素还没有遍历，这题中，就是不能从左至右遍历，应该斜着遍历或者从上往下遍历
- 切片的时候注意，右边时开区间